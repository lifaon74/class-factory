import { TraitToString } from '../traits/built-in/others/trait-to-string';
import { ALLOC, TraitAlloc } from '../traits/built-in/others/trait-alloc/trait-alloc';
import { TraitSubtract } from '../traits/built-in/arithmetic/trait-subtract/trait-subtract';
import { TraitNegate } from '../traits/built-in/arithmetic/trait-negate';
import {
  callTraitMethodOnObject,
  mixTraitsWithInterfaceTyping,
  mixTraitsWithUnionTyping,
  traitIsImplementedBy,
} from '../traits/public';
import { TraitAdd } from '../traits/built-in/arithmetic/trait-add';
import { Trait } from '../traits/trait/trait-class';
import { TraitAllocFromThisPrototype } from '../traits/built-in/others/trait-alloc/trait-alloc-from-this-prototype';

/** STRUCTURE **/

interface Vector2Struct {
  x: number;
  y: number;
}

/** METHODS (without alloc) **/

abstract class TraitVector2Length extends Trait {
  length(this: Vector2Struct): number {
    return Math.sqrt((this.x * this.x) + (this.y * this.y));
  }
}

abstract class TraitVector2ToString extends TraitToString {
  toString(this: Vector2Struct): string {
    return `vec2(${ this.x }, ${ this.y })`;
  }
}

/** ALLOC **/

abstract class TraitVector2AllocFromThisPrototype extends TraitAllocFromThisPrototype<Vector2Struct, Vector2Struct, unknown> {
}

export type TTraitVector2WithAllocAndStruct =
  TraitVector2AllocFromThisPrototype
  & Vector2Struct;


/** METHODS (with alloc) **/

abstract class TraitVector2Normalize extends Trait {
  normalize(this: TTraitVector2WithAllocAndStruct): TTraitVector2WithAllocAndStruct {
    const length: number = callTraitMethodOnObject(TraitVector2Length, 'length', this, []);
    return this[ALLOC]({
      x: this.x / length,
      y: this.y / length,
    }) as TTraitVector2WithAllocAndStruct;
  }
}

// abstract class TraitVector2Normalize extends TraitVector2Length {
//   normalize(this: TTraitVector2WithAllocAndStruct): this {
//     const length = callTraitMethodOnObject(TraitVector2Length, 'length', this, []);
//     return this[ALLOC]({
//       x: this.x / length,
//       y: this.y / length,
//     });
//   }
// }
//
// abstract class TraitVector2Add extends mixTraitsWithUnionTyping([TraitAdd, TraitVector2Alloc], Trait) {
//   add(this: Vector2Struct & TraitVector2Alloc, value: Vector2Struct): this {
//     return this[ALLOC]({
//       x: this.x + value.x,
//       y: this.y + value.y,
//     }) as this;
//   }
// }

abstract class TraitVector2AddSelf extends Trait {
  addSelf(this: Vector2Struct, value: Vector2Struct): this {
    this.x += value.x;
    this.y += value.y;
    return this as any;
  }
}

abstract class TraitVector2Sub extends mixTraitsWithUnionTyping([TraitSubtract, TraitVector2Alloc], Trait) {
  subtract(this: Vector2Struct & TraitVector2Alloc, value: Vector2Struct): this {
    return this[ALLOC]({
      x: this.x - value.x,
      y: this.y - value.y,
    }) as this;
  }
}

abstract class TraitVector2Negate extends mixTraitsWithUnionTyping([TraitNegate, TraitVector2Alloc], Trait) {
  negate(this: Vector2Struct): this {
    return this[ALLOC]({
      x: -this.x,
      y: -this.y,
    }) as this;
  }
}


interface IVector2Trait extends TraitVector2Length,
  TraitVector2Normalize,
  TraitVector2Add,
  TraitVector2Negate,
  TraitVector2Sub,
  TraitVector2ToString,
  TraitVector2AddSelf,
  TraitVector2AllocFromThisPrototype {
}

const Vector2Trait = mixTraitsWithInterfaceTyping<IVector2Trait, typeof Trait>([
  TraitVector2Length,
  TraitVector2Normalize,
  TraitVector2Add,
  TraitVector2Negate,
  TraitVector2Sub,
  TraitVector2ToString,
  TraitVector2AddSelf,
  TraitVector2AllocFromThisPrototype,
]);

class Vector2 extends Vector2Trait implements Vector2Struct {
  x: number;
  y: number;

  constructor(x: number, y: number) {
    super();
    this.x = x;
    this.y = y;
  }
}


export async function debugVector2() {
  const a = new Vector2(1, 2);
  console.log(a.negate().toString());
  console.log(a.addSelf(new Vector2(4, 5)).toString());
  console.log(a.normalize());


  console.log(traitIsImplementedBy(TraitVector2AllocFromThisPrototype, a));
  console.log(traitIsImplementedBy(Vector2, a));

  (window as any).Vector2 = Vector2;
  // const vecA$ = implementTraits([TraitVector2ToString, TraitVector2Negate, TraitVector2AllocFromThis] as (typeof TraitVector2ToString | typeof TraitVector2Negate | typeof TraitVector2AllocFromThis)[], vecA);
  // console.log(vecA$.negate().toString());

  // console.log(traitIsImplementedBy(TraitVector2ToString, vecA));
  // console.log(traitIsImplementedBy(TraitVector2New, vecA));
  // console.log(traitIsImplementedBy(TraitVector2NewWithTraits, vecA));
  //
  // console.log(vecA$.toString());
}

import { Constructor, ExcludeConstructor } from './types/class-types';
import { TupleToIntersection } from './types/misc-types';
import { GetSafeAndUniqPropertyDescriptors, ObjectHasOwnProperty } from './helpers';


export interface TClassTrait<GInstance> {
  prototype: GInstance;
}

export type TInferClassTrait<GClassTrait extends TClassTrait<any>> =
  GClassTrait extends TClassTrait<infer GTrait>
    ? GTrait
    : never;

export type TInferClassTraits<GClassTraits extends TClassTrait<any>[]> = {
  [GKey in keyof GClassTraits]:  GClassTraits[GKey] extends TClassTrait<infer GTrait>
    ? GTrait
    : never;
};

export type TMakeTraitsIntersection<GTraits extends object[]> = TupleToIntersection<GTraits>;

export type TMakeSuperTraitInstance<GTraits extends object[], GBaseClass extends Constructor> =
  TMakeTraitsIntersection<GTraits>
  & InstanceType<GBaseClass>;

export type TMakeSuperTrait<GTraits extends object[], GBaseClass extends Constructor> =
  ExcludeConstructor<GBaseClass>
  & {
  new(...args: ConstructorParameters<GBaseClass>): TMakeSuperTraitInstance<GTraits, GBaseClass>;
};

export type TBaseClassIsUndefinedOrVoid<GBaseClass extends (Constructor | void | undefined)>
  = [void] extends [GBaseClass]
  ? true
  : (
    [undefined] extends [GBaseClass]
      ? true
      : false
    );

export type TMakeSuperTraitWithVoidAllowed<GTraits extends object[], GBaseClass extends (Constructor | void | undefined)> =
  TBaseClassIsUndefinedOrVoid<GBaseClass> extends true
    ? {
      new(): TMakeTraitsIntersection<GTraits>;
    }
    : TMakeSuperTrait<GTraits, Exclude<GBaseClass, void>>;





/*----------------------------*/

/* AS FUNCTIONS */

export type TTraitFunctionFunction<GInstance extends object> = (this: GInstance, ...args: any[]) => any;
// export type TTraitFunctionFunctionWithThisAsFirstParameter<GInstance extends object> = (instance: GInstance, ...args: any[]) => any;

export type TObjectWithTraitFunction<GObject extends object, GPropertyKey extends PropertyKey, GFunction extends TTraitFunctionFunction<GObject>> = GObject & Record<GPropertyKey, GFunction>;
// export type TDerivedFunctionConstraint<GFunction extends TGenericFunction> = (...args: [...Parameters<GFunction>, ...any[]]) => ReturnType<GFunction>;

// export type TTraitFunctionFunctionWithThisAsFirstParameterToTTraitFunctionFunction<
//   GInstance extends object,
//   GFunction extends TTraitFunctionFunctionWithThisAsFirstParameter<GInstance>
// > = GFunction extends (instance: GInstance, ...args: infer GArgs) => infer GReturn
//   ? (this: GInstance, ...args: GArgs) => GReturn
//   : never;

export interface TTraitFunctionOptions {
  enumerable?: boolean;
  configurable?: boolean;
  writable?: boolean;
}

export class TraitFunction<GInstance extends object, GPropertyKey extends PropertyKey, GFunction extends TTraitFunctionFunction<GInstance>> {

  // static createAbstract<GInstance extends object, GPropertyKey extends PropertyKey, GFunction extends TTraitFunctionFunction<GInstance>>(
  //   propertyKey: GPropertyKey,
  //   options?: TTraitFunctionOptions,
  // ): TraitFunction<GInstance, GPropertyKey, GFunction> {
  //   return new TraitFunction<GInstance, GPropertyKey, GFunction>(
  //     propertyKey,
  //     ((): ReturnType<GFunction> => {
  //       throw new Error(`Cannot call abstract method '${ String(propertyKey) }'`);
  //     }) as GFunction,
  //     options
  //   );
  // }
  //
  // static createWithThisAsFirstParameter<GInstance extends object, GPropertyKey extends PropertyKey, GFunction extends TTraitFunctionFunctionWithThisAsFirstParameter<GInstance>>(
  //   propertyKey: GPropertyKey,
  //   fnc: GFunction,
  //   options?: TTraitFunctionOptions,
  // ): TraitFunction<GInstance, GPropertyKey, TTraitFunctionFunctionWithThisAsFirstParameterToTTraitFunctionFunction<GInstance, GFunction>> {
  //   type GFunctionWithThis = TTraitFunctionFunctionWithThisAsFirstParameterToTTraitFunctionFunction<GInstance, GFunction>;
  //   return new TraitFunction<GInstance, GPropertyKey, GFunctionWithThis>(
  //     propertyKey,
  //     (function (this: GInstance, ...args: Parameters<GFunctionWithThis>): ReturnType<GFunctionWithThis> {
  //       return fnc.call(this, this, ...args);
  //     }) as GFunctionWithThis,
  //     options
  //   );
  // }

  readonly propertyKey: GPropertyKey;
  readonly fnc: GFunction;
  readonly enumerable: boolean;
  readonly configurable: boolean;
  readonly writable: boolean;

  protected _derived: TraitFunction<GInstance, GPropertyKey, GFunction>[];
  protected _implementedBy: WeakSet<GInstance>;

  constructor(
    propertyKey: GPropertyKey,
    fnc: GFunction,
    options: TTraitFunctionOptions = {},
  ) {
    this.propertyKey = propertyKey;
    this.fnc = fnc;
    this.enumerable = (options.enumerable === void 0) ? true : options.enumerable;
    this.configurable = (options.configurable === void 0) ? true : options.configurable;
    this.writable = (options.writable === void 0) ? false : options.writable;
    this._derived = [];
  }

  derive<GDerivedFunction extends GFunction>(
    fnc: GDerivedFunction,
    options: TTraitFunctionOptions = {},
  ): TraitFunction<GInstance, GPropertyKey, GDerivedFunction> {
    return new TraitFunction<GInstance, GPropertyKey, GDerivedFunction>(
      this.propertyKey,
      fnc,
      {
        enumerable: (options.enumerable === void 0) ? this.enumerable : options.enumerable,
        configurable: (options.configurable === void 0) ? this.configurable : options.configurable,
        writable: (options.writable === void 0) ? this.writable : options.writable,
      }
    );
  }

  callFor(instance: GInstance, args: Parameters<GFunction>): ReturnType<GFunction> {
    return this.fnc.apply(instance, args);
  }

  implementFor<GObject extends GInstance>(obj: GObject): TObjectWithTraitFunction<GObject, GPropertyKey, GFunction> {
    if (ObjectHasOwnProperty(obj, this.propertyKey)) {
      throw new Error(`The property '${ String(this.propertyKey) }' is already implemented`);
    } else {
      Object.defineProperty(obj, this.propertyKey, {
        value: this.fnc,
        enumerable: this.enumerable,
        configurable: this.configurable,
        writable: this.writable,
      });
      this._implementedBy.add(obj);
    }
    return obj as TObjectWithTraitFunction<GObject, GPropertyKey, GFunction>;
  }

  isImplementedBy<GObject>(obj: GObject): obj is (GObject extends GInstance ? TObjectWithTraitFunction<GObject, GPropertyKey, GFunction> : never) {
    if (typeof obj === 'object') {
      while (obj !== null) {
        if (
          this._implementedBy.has(obj as any)
          || this._derived.some((derived: TraitFunction<GInstance, GPropertyKey, GFunction>) => derived.isImplementedBy<GObject>(obj))
        ) {
          return true;
        } else {
          obj = Object.getPrototypeOf(obj);
        }
      }
      return false;
    } else {
      return false;
    }
  }

}


/* AS OBJECT */

// export type TTraitObjectConstraint<GTrait extends object> = Record<PropertyKey, TTraitFunctionFunction<GTrait>>;
//
// export class Trait<GTrait extends TTraitObjectConstraint<GTrait>> {
//
// }



// type fnc1 = (a: number) => number;
// type fnc2 = (a: number, b?: number) => number;
// const a: (fnc1 extends fnc2 ? true : false) = null as any;
// const b: (fnc2 extends fnc1 ? true : false) = null as any;

// const t1 = new TraitFunction<'a', fnc1>('a', () => 1);
// const t2 = t1.derive<fnc2>(() => 2);

/* AS TRAIT (OBJECT) */

// export type TTrait = Record<PropertyKey, TGenericFunction>;
//
// export type TTraitConstraint<GTrait> = {
//   [GKey in keyof GTrait]: GTrait[GKey] extends TGenericFunction
//     ? object
//     : never;
// };
//
// export type TObjectWithTrait<GObject, GTrait extends TTrait> = (GObject & GTrait);
//
//
// export function ImplementTrait<GObject, GTrait extends TTrait>(obj: GObject, trait: GTrait): TObjectWithTrait<GObject, GTrait> {
//   const iterator: Iterator<[PropertyKey, PropertyDescriptor, Object]> = GetSafeAndUniqPropertyDescriptors(trait);
//   let result: IteratorResult<[PropertyKey, PropertyDescriptor, Object]>;
//   while (!(result = iterator.next()).done) {
//     const [propertyKey, descriptor, target]: [PropertyKey, PropertyDescriptor, Object] = result.value;
//     if (ObjectHasOwnProperty(obj, propertyKey)) {
//       throw new Error(`The property '${ String(propertyKey) }' is already implemented`);
//     } else {
//       Object.defineProperty(obj, propertyKey, descriptor);
//     }
//   }
//   return obj as any;
// }



/*----------------------------*/


// export const TRAITS = Symbol('traits');
//
//
// export function RegisterTrait(obj: any, trait: object): void {
//   if (ObjectHasOwnProperty(obj, TRAITS)) {
//     obj[TRAITS].add(trait);
//   } else {
//     Object.defineProperty(obj, TRAITS, {
//       value: new WeakSet<object>([trait]),
//       writable: false,
//       enumerable: false,
//       configurable: false,
//     });
//   }
// }
//
// export function RegisterTraits(obj: any, traits: object[]): void {
//   for (let i = 0, l = traits.length; i < l; i++) {
//     RegisterTrait(obj, traits[i]);
//   }
// }
//
//
// export function ImplementTrait<GObject, GTrait extends object>(obj: GObject, trait: GTrait): (GObject & GTrait) {
//   const iterator: Iterator<[PropertyKey, PropertyDescriptor, Object]> = GetSafePropertyDescriptors(trait);
//   let result: IteratorResult<[PropertyKey, PropertyDescriptor, Object]>;
//   while (!(result = iterator.next()).done) {
//     const [propertyKey, descriptor, target]: [PropertyKey, PropertyDescriptor, Object] = result.value;
//     if (propertyKey !== TRAITS) {
//       if (ObjectHasOwnProperty(obj, propertyKey)) {
//         throw new Error(`The property '${ String(propertyKey) }' is already implemented`);
//       } else {
//         RegisterTrait(obj, target);
//         Object.defineProperty(obj, propertyKey, descriptor);
//       }
//     }
//   }
//   return obj as any;
// }
//
// export function ImplementTraits<GObject, GTraits extends object[]>(obj: GObject, traits: GTraits): (GObject & TMakeTraitsIntersection<GTraits>) {
//   for (let i = 0, l = traits.length; i < l; i++) {
//     ImplementTrait(obj, traits[i]);
//   }
//   return obj as any;
// }
//
//
//
// export function SuperTraits<GTraits extends object[], GBaseClass extends (Constructor | void | undefined)>(traits: GTraits, baseClass?: GBaseClass): TMakeSuperTraitWithVoidAllowed<GTraits, GBaseClass> {
//   const TraitClass = (baseClass === void 0)
//     ? class TraitClass {}
//     : // @ts-ignore
//     class TraitClass extends baseClass {};
//   ImplementTraits(TraitClass.prototype, traits);
//   return TraitClass as any;
// }
//
//
// export function ImplementsTrait<GObject, GTrait extends object>(obj: GObject, trait: GTrait): obj is (GObject & GTrait) {
//   while (obj !== null) {
//     if (
//         ObjectHasOwnProperty(obj, TRAITS)
//         && (obj[TRAITS] as WeakSet<object>).has(trait)
//       ) {
//       return true;
//     } else {
//       obj = Object.getPrototypeOf(obj);
//     }
//   }
//   return false;
// }
//
// export function ImplementsTraits<GObject, GTraits extends object[]>(obj: GObject, traits: GTraits): obj is (GObject & TMakeTraitsIntersection<GTraits>) {
//   return traits.every((trait: object) => ImplementsTrait<GObject, object>(obj, trait))
// }
//
//
// export function TraitFromClass<GClassTrait extends TClassTrait<any>>(classTrait: GClassTrait): TInferClassTrait<GClassTrait> {
//   return classTrait.prototype;
// }
//
// export function TraitsFromClasses<GClassTraits extends TClassTrait<any>[]>(...classTrait: GClassTraits): TInferClassTraits<GClassTraits> {
//   return classTrait.map(TraitFromClass) as TInferClassTraits<GClassTraits>;
// }
//
//
// export function CallTraitMethodOrFallback<
//   GInstance,
//   GMethodName extends PropertyKey,
//   GArgs extends any[],
//   GReturn,
//   GTrait extends Record<GMethodName, (...args: GArgs) => GReturn>>(
//   instance: GInstance,
//   methodName: PropertyKey,
//   trait: GTrait,
//   args: GArgs,
//   fallback: (instance: GInstance, ...args: GArgs) => GReturn,
// ): GReturn {
//   if (ImplementsTrait<GInstance, GTrait>(instance, trait)) {
//     return instance[methodName](...args);
//   } else {
//     return fallback(instance, ...args);
//   }
// }
//
// // export function CallTraitMethodOrFallback<
// //   GInstance,
// //   GMethodName extends PropertyKey,
// //   GMethod extends (...args: any[]) => any,
// //   GTrait extends Record<GMethodName, GMethod>>(
// //   instance: GInstance,
// //   methodName: PropertyKey,
// //   fallback: GMethod,
// //   trait: GTrait,
// //   args: Parameters<GMethod>,
// // ): ReturnType<GMethod> {
// //   if (ImplementsTrait<GInstance, GTrait>(instance, trait)) {
// //     return instance[methodName](...args);
// //   } else {
// //     return fallback();
// //   }
// // }
//
//


